import os 
import time
import json
from .log_utils import Colors
import warnings
from .utils import write_json, load_json_as_dict, get_filename_from_token

'''
redis stuff so that different eden replicas can stay in sync
'''
from redis import Redis



class QueueData(object):
    """
    Simple way to keep a track of the tasks done on multiple threads. 

    Args:
        filename (str): name of the json file where the data is stored. Defaults to: "__eden_queue__.json"
    """
    def __init__(self, celery_app, redis_port: int,  redis_host: str , filename: str = '__eden_queue__.json'):

        '''
        to wipe all redis stuff, use:
        $ redis-cli flushall
        '''

        self.celery_app = celery_app

        self.redis = Redis(
            host= redis_host,
            port= str(redis_port),
        )

        # self.pipeline = self.redis.pipeline()

        self.filename = filename

        self.queue = []  ## used to find position on the queue

        ## so that the API remains the same from the outside
        self.name_mapping = {
            'PENDING': 'queued',
            'STARTED': 'running',
            'SUCCESS': 'complete',
            'FAILURE': 'failed'
        }


    def get_queue(self):
        tokens_in_queue = []

        queue_stuff = self.redis.hgetall('unacked')
        if queue_stuff is not None:

            keys= queue_stuff.keys()
            for k in keys: 

                token_standing_in_queue = json.loads(queue_stuff[k].decode('utf-8'))[0]['headers']['root_id']
                
                tokens_in_queue.append(token_standing_in_queue)

        return  tokens_in_queue

    def check_if_token_in_queue(self, token):
        tokens_in_queue = self.get_queue()

        if token in tokens_in_queue: 
            return True
        else:
            return False

    def get_status(self, token):

        '''
        note: a VERY common source of latency generated by the execution 
        of slow commands is the use of the KEYS command in production environments. 
        KEYS (or self.redis.keys()), as documented in the Redis documentation, should only be used for 
        debugging purposes.

        source: https://redis.io/topics/latency
        '''

        
        in_queue = self.check_if_token_in_queue(token = token)

        if in_queue == True: 
            '''
            The job is in queue
            '''
            status_to_return = {
                'status': 'queued',
            }
            
            queue_pos = self.get_queue_position(token = token)
            status_to_return['queue_position'] = queue_pos

        else:
            '''
            The job is either complete or running, 
            these can be found on the redis keys
            '''

            full_token = 'celery-task-meta-' + token
            response_bytes = self.redis.get(full_token)  ##.execute()[0]

            if response_bytes is not None:

                dict_str = response_bytes.decode("UTF-8")

                ## convert to dict and extract status
                status = json.loads(dict_str)['status']
                status = self.name_mapping[status]

                status_to_return = {
                    'status': status,
                }

            else:

                status_to_return = {
                    'status': 'invalid token',
                    # 'in queue': in_queue
                }

        return status_to_return

    def __getitem__(self, token):
        return self.get_status(token = token)

    def add_to_queue(self, token, res):
        
        self.queue.append(token)
        
    def set_as_running(self, token):
        try:
            self.queue.remove(token)
        except:
            pass

    def get_queue_position(self, token):
        try:
            pos = self.get_queue().index(token)
        except:
            pos = None
            raise Exception(f'token: {token} not found in {self.get_queue()}')
        return pos 